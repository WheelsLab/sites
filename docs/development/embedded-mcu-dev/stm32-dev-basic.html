<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-development/embedded-mcu-dev/stm32-dev-basic/README" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">STM32 基础 | WheelsLab</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://WheelsLab.github.io/sites/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://WheelsLab.github.io/sites/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://WheelsLab.github.io/sites/docs/development/embedded-mcu-dev/stm32-dev-basic"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="STM32 基础 | WheelsLab"><meta data-rh="true" name="description" content="微控制器（MCU, Microcontroller）概述"><meta data-rh="true" property="og:description" content="微控制器（MCU, Microcontroller）概述"><link data-rh="true" rel="icon" href="/sites/img/favicon.png"><link data-rh="true" rel="canonical" href="https://WheelsLab.github.io/sites/docs/development/embedded-mcu-dev/stm32-dev-basic"><link data-rh="true" rel="alternate" href="https://WheelsLab.github.io/sites/docs/development/embedded-mcu-dev/stm32-dev-basic" hreflang="en"><link data-rh="true" rel="alternate" href="https://WheelsLab.github.io/sites/docs/development/embedded-mcu-dev/stm32-dev-basic" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"嵌入式软件开发","item":"https://WheelsLab.github.io/sites/docs/development/embedded-mcu-dev/"},{"@type":"ListItem","position":2,"name":"STM32 基础","item":"https://WheelsLab.github.io/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/"}]}</script><link rel="alternate" type="application/rss+xml" href="/sites/blog/rss.xml" title="WheelsLab RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/sites/blog/atom.xml" title="WheelsLab Atom Feed">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.css" integrity="sha384-m7LqaUc4JRc2uA7D4zSVUs/sgkYhmOOe9+Gd8DFmmAXH8vzs15fmw05YXvpxsoQB" crossorigin="anonymous"><link rel="stylesheet" href="/sites/assets/css/styles.54e22259.css">
<script src="/sites/assets/js/runtime~main.a7f612d2.js" defer="defer"></script>
<script src="/sites/assets/js/main.4d285f79.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/sites/img/favicon.png"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/sites/"><div class="navbar__logo"><img src="/sites/img/favicon.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/sites/img/favicon.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">WheelsLab</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">知识库</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/sites/docs/cs-complete/Automata-Theory">CS 补完计划</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/sites/docs/development/embedded-mcu-dev">软件开发</a></li><li><a class="dropdown__link" href="/sites/docs/linux-playground">Linux 折腾笔记</a></li><li><a class="dropdown__link" href="/sites/docs/scientific-networking">科学上网</a></li><li><a class="dropdown__link" href="/sites/docs/miscellaneous">杂项</a></li><li><a class="dropdown__link" href="/sites/about-this-site">关于本站</a></li></ul></div><a class="navbar__item navbar__link" href="/sites/blog">博客</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/WheelsLab/doc" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/sites/"><img src="/sites/img/favicon.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/sites/img/favicon.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>WheelsLab</b></a><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--active" href="/sites/docs/development/embedded-mcu-dev"><span title="嵌入式软件开发" class="categoryLinkLabel_W154">嵌入式软件开发</span></a><button aria-label="Collapse sidebar category &#x27;嵌入式软件开发&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/bare-metal-programming"><span title="裸机编程" class="categoryLinkLabel_W154">裸机编程</span></a><button aria-label="Expand sidebar category &#x27;裸机编程&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible menu__list-item-collapsible--active"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--active" aria-current="page" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic"><span title="STM32 基础" class="categoryLinkLabel_W154">STM32 基础</span></a><button aria-label="Collapse sidebar category &#x27;STM32 基础&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/GPIO"><span title="GPIO（通用输出/输出）" class="linkLabel_WmDU">GPIO（通用输出/输出）</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/UART"><span title="UART（串口）" class="linkLabel_WmDU">UART（串口）</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/I2C"><span title="I2C" class="linkLabel_WmDU">I2C</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/SPI"><span title="SPI" class="linkLabel_WmDU">SPI</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/Interrupt"><span title="中断" class="linkLabel_WmDU">中断</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/EXTI"><span title="EXTI" class="linkLabel_WmDU">EXTI</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/Clock"><span title="时钟（Clock）" class="linkLabel_WmDU">时钟（Clock）</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/Timer"><span title="定时器（Timer）" class="linkLabel_WmDU">定时器（Timer）</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/ADC"><span title="模数转换（ADC）" class="linkLabel_WmDU">模数转换（ADC）</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/sites/docs/development/embedded-mcu-dev/stm32-project-blance-car"><span title="STM32 平衡车" class="categoryLinkLabel_W154">STM32 平衡车</span></a><button aria-label="Expand sidebar category &#x27;STM32 平衡车&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sites/docs/development/learn-react"><span title="React" class="linkLabel_WmDU">React</span></a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/sites/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/sites/docs/development/embedded-mcu-dev"><span>嵌入式软件开发</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">STM32 基础</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>STM32 基础</h1></header>
<h1><del>STM32 系列单片机整体概述</del>，<del>包括芯片架构~~~~、存储器映射、总线体系（AHB / APB）</del>、中断与异常机制以及基本开发流程</h1>
<h2 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="微控制器mcu-microcontroller概述">微控制器（MCU, Microcontroller）概述<a href="#微控制器mcu-microcontroller概述" class="hash-link" aria-label="Direct link to 微控制器（MCU, Microcontroller）概述" title="Direct link to 微控制器（MCU, Microcontroller）概述" translate="no">​</a></h2>
<p>单片机就是MCU+外围电路，MCU 就是就是处理器（Processor）+ 片上外设（on-chip Peripheral）。ARM 芯片在单片机处理器领域基本上处于垄断性地位，ST Microelectronics 制造的 STM32 也是最为广泛使用的 MCU 之一。</p>
<p>除了 STM32 外，借助物联网热潮国内也出现了一些 MCU 新秀，比如<a href="https://www.espressif.com.cn/zh-hans/products/socs/esp32" target="_blank" rel="noopener noreferrer" class="">乐鑫科技</a>的 ESP32，以及<a href="https://www.gigadevice.com.cn/" target="_blank" rel="noopener noreferrer" class="">兆易创新</a>的 GD32</p>
<p><img decoding="async" loading="lazy" alt="Microprocessor-based system on a chip" src="/sites/assets/images/960px-ARMSoCBlockDiagram.svg-3be6af931d238e62ed88bacd712c6ba2.png" width="960" height="1152" class="img_ev3q"></p>
<p>STM32 是 ST Microelectronics 基于 ARM Cotex M 内核推出的一系列 MCU，<a href="https://www.stmcu.com.cn/mkt_info/3413" target="_blank" rel="noopener noreferrer" class="">早在 2007</a> 年 ST 公司就发布了第一款基于 ARM Cortex 内核的 MCU，也就是本系列教程用的 STM32F103 ，使用的是 Cortex-M3 内核</p>
<p><img decoding="async" loading="lazy" alt="STM32 history milestone" src="/sites/assets/images/stm32-history-milestone-cd937be546001dc5cd5abd3c975d08d8.png" width="1819" height="747" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="STM32 和 ARM Cortex M3" src="/sites/assets/images/cortex-m3-inside-stm32-74337d155a38d7efaf030a03b1110656.png" width="1321" height="942" class="img_ev3q"></p>
<p>Cortex 分为 3 个系列，A 和 M 的主要区别在于 M 系列没有 MMU 没法运行 Linux 这种复杂操作系统</p>
<ul>
<li class="">A：适用于复杂操作系统，和应用程序的处理器。手机 SoC</li>
<li class="">R：适用于实时操作系统的配置。</li>
<li class="">M：适用于成本敏感的微控制器配置。各种嵌入式设备</li>
</ul>
<p>系列后面的数字代表相对性能，1 为最低 8 为最高，比如 Cortex=M0、Cortex-M3、Cortex-M4</p>
<p>除了使用 Cortex 系列外，ARM 还使用架构版本标识其处理器，比如 Cortex-M3 使用的是 ARMv7</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>这两篇 Wiki 很好概述了ARM Cortex 系列和架构版本</div><div class="admonitionContent_BuS1"><p>个人感觉 Cortex 就类似 intel CPU 的酷睿、奔腾、赛扬代表不同的性能级别和不同的目标客户，而数字则类似 i3、i5、i7 这种同系列内的性能分级。至于版本架构就代表某一代 CPU 的架构代号，比如 Alder Lake、Lunar Lake，同一代的 CPU 都是采用的一种架构。</p><p>ARM Cortex 系列：</p><ul>
<li class="">Cortex-M：<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M" target="_blank" rel="noopener noreferrer" class="">https://en.wikipedia.org/wiki/ARM_Cortex-M</a></li>
<li class="">Cortex-A：<a href="https://en.wikipedia.org/wiki/ARM_Cortex-A" target="_blank" rel="noopener noreferrer" class="">https://en.wikipedia.org/wiki/ARM_Cortex-A</a></li>
</ul><p>ARM 架构版本：<a href="https://en.wikipedia.org/wiki/ARM_architecture_family" target="_blank" rel="noopener noreferrer" class="">https://en.wikipedia.org/wiki/ARM_architecture_family</a></p><p><img decoding="async" loading="lazy" alt="image-20260123102140203" src="/sites/assets/images/image-20260123102140203-44e170869ca257de53300d84fe75c5d5.png" width="1444" height="506" class="img_ev3q"></p></div></div>
<p>STM32 系列的命名规则也是类似，比如 F、L、H 都是根据产品的应用场景和性能划分</p>
<p><img decoding="async" loading="lazy" alt="stm32-product-series" src="/sites/assets/images/stm32-product-series-337d50f9fb3ed037801cca307771542f.png" width="1618" height="907" class="img_ev3q"></p>
<p>下图是命名规则，可以看到除了首字母代表的系列外，后面的各种后缀则代表了更详细的性能划分和电气特性。</p>
<p><img decoding="async" loading="lazy" alt="STM32_MCU_Selection_Guide" src="/sites/assets/images/STM32_MCU_Selection_Guide-b86b3e6fd8318d6ab2eaf0d191231899.png" width="1895" height="1089" class="img_ev3q"></p>
<h2 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="arm-cortex-m">ARM Cortex-M<a href="#arm-cortex-m" class="hash-link" aria-label="Direct link to ARM Cortex-M" title="Direct link to ARM Cortex-M" translate="no">​</a></h2>
<p>俗话说“一流公司制定标准，二流公司做品牌，三流公司做产品”，ARM 就是这种一流公司</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</div><div class="admonitionContent_BuS1"><p>下面这本书是 ARM Cortex-M 的权威指南，作者是 ARM 的资深工程师。（中文版是《Cortex M3/M4 权威指南》，翻译得不好，不如直接看英文原版）</p><ul>
<li class=""><a href="https://www.amazon.com/Definitive-Guide-Cortex%C2%AE-M3-Cortex%C2%AE-M4-Processors/dp/0124080820" target="_blank" rel="noopener noreferrer" class="">The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors 3rd Edition</a></li>
</ul><p>后续所有关于 ARM Cortex 的内容都参考此书。</p><p>实际上这是一系列书，包括 Cortex M0/M33......</p><ul>
<li class=""><a href="https://www.amazon.com/Definitive-Guide-Cortex-Cortex-M0-Processors/dp/0128032774/ref=sims_dp_d_dex_ai_rank_model_1_d_v1_d_sccl_1_2/138-7367255-5244911?pd_rd_w=9pwg7&amp;content-id=amzn1.sym.bb4a0aac-c2b4-4b4b-a0c8-9aa89b28dce3&amp;pf_rd_p=bb4a0aac-c2b4-4b4b-a0c8-9aa89b28dce3&amp;pf_rd_r=CFD2D20Y5NEPV74RE5TD&amp;pd_rd_wg=eJS4U&amp;pd_rd_r=9bd98503-83bb-440b-b2fa-625b26f72f25&amp;pd_rd_i=0128032774&amp;psc=1" target="_blank" rel="noopener noreferrer" class="">The Definitive Guide to ARM Cortex -M0 and Cortex-M0+ Processors 2nd Edition</a></li>
<li class=""><a href="https://www.amazon.com/Definitive-Guide-Cortex-M23-Cortex-M33-Processors-ebook/dp/B08PPMBW95?ref_=ast_author_dp_rw&amp;th=1&amp;psc=1&amp;dib=eyJ2IjoiMSJ9.9HCcNCHYzUAcrLPj8CoKXVIwtjZpIbi3ZGSZneaPPWU7eRCAhsOu-W_NgCAFKZ2CfpqGjQiWjNwJEj994bMdAz2gb_2Vo-uE3gPPe9E8L6TE6T5oiGJpVuKnOc4bRKxikLwUCvGJrqlVcpEoWCOM3g.7PnaHyz0AqFTPcgCLfWU0RdTxFpmDE6DBtuJTDw3QS8&amp;dib_tag=AUTHOR" target="_blank" rel="noopener noreferrer" class="">Definitive Guide to Arm Cortex-M23 and Cortex-M33 Processors 1st Edition, Kindle Edition</a></li>
</ul></div></div>
<p>Cortex-M 是 ARM 设计的 32-bit RISC 哈佛架构 CPU（Cortex-M3 发布于2005，Cortex-M4 于2010），指令集架构（Instruction Set Architecture, ISA）是 Thumb-2。</p>
<details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>32 bit</summary><div><div class="collapsibleContent_i85q"><ul>
<li class="">
<p>32 位寄存器：处理器内部的通用寄存器宽度为 32 位，也就是说一次可以存放和处理 32 位（4 字节）的数据。</p>
</li>
<li class="">
<p>32 位内部数据通路：处理器内部用于传输和处理数据的数据通路宽度为 32 位，保证了算术运算和数据处理以 32 位为基本单位进行。</p>
</li>
<li class="">
<p>32 位总线接口：处理器与存储器或外设之间的数据总线宽度为 32 位，意味着一次总线访问可以传输 32 位的数据。</p>
</li>
</ul></div></div></details>
<p><img decoding="async" loading="lazy" alt="image-20260123122505073" src="/sites/assets/images/Cortex-M_processor-family-fd9cda3cbe7420a4e405a0b73478fbb8.png" width="1223" height="709" class="img_ev3q"></p>
<p>比较令人意外的是，作为一家设计 CPU 的公司，和 AMD 和 Intel 不同的是，ARM 没有自己的晶圆厂也不生产和制造 CPU，而是将 CPU 设计卖给芯片原厂（vendor），这种销售方式也叫 IP（Intellectualy Property）授权。</p>
<p><img decoding="async" loading="lazy" alt="ARM and MCU vendor" src="/sites/assets/images/ARM-and-MCU-vendor-bd9aabafe1ea98658dfd35524bf6e205.png" width="1712" height="765" class="img_ev3q"></p>
<p>ARM 官网有 Cortex-M 系列处理器的手册，大部分和从事微控制器设计的硬件工程师以及从事芯片原厂开发（middleware 比如 HAL、esp-idf 等）和从事操作系统开发的系统程序员有关，作为应用程序员应该更关注芯片原厂的文档和手册。</p>
<p>对于 MCU 来说处理器仅仅是一部分，时钟系统、存储系统（Flash、SRAM 等）、系统总线、外设这些都由芯片原厂设计（microcontroller vendors），比如 ST Microelectronics、Infineon、NXP、Texas Instrument、Atmel......</p>
<p><img decoding="async" loading="lazy" alt="Processor in MCU" src="/sites/assets/images/Processor-in-MCU-a6b7f522b5d3308a33c382c893dd178d.png" width="691" height="827" class="img_ev3q"></p>
<p>下面，来看下<strong>处理器架构</strong>（Processor Architecture），</p>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</div><div class="admonitionContent_BuS1"><p>在典型应用中，开发者<strong>不必了解 Cortex-M 架构的所有细节</strong>，例如内部实现或微架构层面的内容。实际开发所需的知识主要集中在以下几个方面：</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Details</summary><div><div class="collapsibleContent_i85q"><ul>
<li class=""><strong>程序员模型</strong>：了解有哪些寄存器、它们的基本用途，以及软件如何与处理器交互。</li>
<li class=""><strong>异常机制</strong>：理解异常和中断是如何产生、响应和处理的，这是实时系统和外设驱动的基础。</li>
<li class=""><strong>内存映射</strong>：知道程序、数据和外设在地址空间中的分布方式。</li>
<li class=""><strong>外设使用方法</strong>：掌握如何配置和使用芯片上的定时器、通信接口、GPIO 等外设。</li>
<li class=""><strong>厂商提供的软件驱动库</strong>：学会使用芯片厂商提供的库文件（如 HAL、LL、驱动包），以提高开发效率并减少底层细节处理。</li>
</ul></div></div></details></div></div>
<ul>
<li class="">
<p>指令集（Instruction Set）：ISA 是处理器架构最重要的部分之一，Cortex M 全系使用 <a href="https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings" target="_blank" rel="noopener noreferrer" class="">Thumb</a> 指令集</p>
<p><img decoding="async" loading="lazy" alt="Instruction Set" src="/sites/assets/images/Cortex-M_Instruction-Set-18cb2731b7965c08f87183f58d8878fd.png" width="1394" height="1712" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="image-20260123184737015" src="/sites/assets/images/image-20260123184737015-eb2d34fff5f5545f2a80af7cccb76ba1.png" width="1231" height="989" class="img_ev3q"></p>
</li>
<li class="">
<p><a href="https://electronics.stackexchange.com/questions/365367/what-is-a-programmers-model" target="_blank" rel="noopener noreferrer" class="">程序员模型（Programmer&#x27;s Model）</a>：处理器内部用于存放和处理数据的这些寄存器，以及它们的功能和使用方式，统称为程序员模型（programmer’s model）。</p>
</li>
<li class="">
<p>异常模型（Exception and Interrupt）：Cortex-M 处理器使用 Nested Vectored Interrupt Controller (NVIC)，是一种可编程中断控制器。可以处理外设中断和外部输入以及系统异常（system exception）包括 NMI（Non-Maskable Interrupt）以及处理器自身引发的异常。MCU 原厂可以决定中断信号和优先级的数量。异常和中断的处理在各种 NVIC 实现对于程序员模型来说其表现都是相同的。</p>
</li>
<li class="">
<p>调试架构（Debug）：</p>
</li>
</ul>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>架构和微架构</div><div class="admonitionContent_BuS1"><p>Cortex-M3 和 Cortex-M4 都是 ARMv7-M 架构的具体实现</p><ul>
<li class="">架构（Architecture）是指处理器中<strong>对软件可见的部分</strong>包括指令集架构（Instruction Set Architecture，ISA）、程序员模型（寄存器、中断模型等，软件能看到的内容）、调试机制（调试器所看到和使用的机制）</li>
<li class="">微架构（Micro-architecture）这是<strong>处理器内部的具体实现方式</strong>，包括：接口信号、指令执行时序、流水线级数等</li>
</ul></div></div>
<p>整体来看 Cortex 处理器内部由多个部分组成处理器核心（三阶段流水线）、NVIC（中断控制器）、Systick 定时器、FPU（可选的浮点处理单元）、内部总线、MPU（内存保护单元）、可选的调试系统</p>
<p><img decoding="async" loading="lazy" alt="Block diagram of Cortex Processor" src="/sites/assets/images/Block-diagram-of-Cortex-Processor-8726eabe98e57bd521b9f73787628261.png" width="1124" height="762" class="img_ev3q"></p>
<p>Cortex M 处理器有许多内部总线，采用的是 Harvard 总线架构（Harvard Bus Architecture）核心特点是指令（I-CODE）存储器和数据（D-CODE）存储器使用独立的总线，即程序代码和数据通过不同的通道访问。还有 System 总线用于访问 RAM 和外设， PPB 和 DAP 用于调试系统</p>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="内存系统memory-system">内存系统（Memory System)<a href="#内存系统memory-system" class="hash-link" aria-label="Direct link to 内存系统（Memory System)" title="Direct link to 内存系统（Memory System)" translate="no">​</a></h3>
<p>Cortex-M 是 32 bit 位寻址的，其地址空间大小是 4GB。</p>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</div><div class="admonitionContent_BuS1"><p>地址空间是 4GB 不代表内存大小可以有 4GB，这里有个概念叫作内存映射 I/O，意思是 CPU 地址空间的一部分被映射到外部设备（Peripheral），这样 CPU 就可以用访问内存的指令访问设备。Linux 的 <code>dmesg</code> 命令开头，会显示部分物理内存是 reserved，以及在 STM32 的 SPL 和 HAL 库中存在大量的寄存器宏定义都是内存映射 I/O 的体现。</p><ul>
<li class="">
<p><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O" target="_blank" rel="noopener noreferrer" class="">Memory-mapped I/O and port-mapped I/O</a></p>
</li>
<li class="">
<p><a href="https://stackoverflow.com/questions/9654504/memory-mapped-io-how-is-it-done" target="_blank" rel="noopener noreferrer" class="">Memory mapped IO - how is it done?</a></p>
</li>
</ul></div></div>
<p>Cortex-M3/M4 没有存储系统，而是留有片上总线接口（on-chip bus interface），存储系统都由 MCU 原厂（microcontroller vendor）设计，包括</p>
<ul>
<li class="">程序内存 flash（Program Memory）</li>
<li class="">数据内存 SRAM（Data Memory）</li>
<li class="">外设（Peripheral）：<strong>外设的控制寄存器被分配在 CPU 的地址空间中，就像普通内存一样访问</strong>。</li>
</ul>
<p>这些总线都基于 Advanced Microcontroller Bus Architecture (AMBA) 标准设计，这是一个开放标准，是 SoC 总线的事实标准，包含很多规范，其中 <strong>AHB</strong> Lite (Advanced High-performance Bus）用于实现程序内存（program memory）和系统总线（system bus interface），另一个是 <strong>APB</strong> (Advanced Peripheral Bus) 规范用于实现外设访问，此外 APB 还用于实现调试系统。</p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="内存映射memory-map">内存映射（Memory Map）<a href="#内存映射memory-map" class="hash-link" aria-label="Direct link to 内存映射（Memory Map）" title="Direct link to 内存映射（Memory Map）" translate="no">​</a></h4>
<p>Cortex-M 处理器具有 32-bit 寻址空间（4GB），整个地址空间结构上被分成多个区域。</p>
<p>这些区域部分分配给了内部组件（NVIC、调试组件），部分可由 MCU vendor 定义。可以从 SRAM 和 RAM （通过 system bus）中执行代码，但 Cortex 并未此种用途做优化，每条指令的取指阶段都需要一个额外的时钟周期，因此性能会稍慢。</p>
<p>下图是内存区域定义（memory region definitions）或者叫内存映射（memory map）</p>
<p>从图中可以看到有许多内建组件（built-in component）的内存映射，各种系统外设（system peripheral）都存在于 SCS （System Control Space）中，包括 NVIC、MPU、SCB 所在的内存空间（memory space）。</p>
<p><img decoding="async" loading="lazy" alt="image-20260123193640643" src="/sites/assets/images/image-20260123193640643-d68abe4358e30aef68459ebc5c5d91a0.png" width="1742" height="1195" class="img_ev3q"></p>
<p>下表是内存映射</p>
<table><thead><tr><th>区域（Region）</th><th>地址范围（Address Range）</th><th>说明</th></tr></thead><tbody><tr><td>代码区（Code）</td><td>0x00000000 – 0x1FFFFFFF</td><td>大小为 512MB，主要用于存放程序代码，包括作为程序存储器一部分的默认中断向量表；同时也允许数据访问。</td></tr><tr><td>SRAM 区</td><td>0x20000000 – 0x3FFFFFFF</td><td>大小为 512MB，主要用于连接 SRAM（通常为片上 SRAM，但不限于此类型）。若实现了可选的位带（bit-band）特性，该区域前 1MB 支持位寻址；也可以在该区域中执行程序代码。</td></tr><tr><td>外设区（Peripherals）</td><td>0x40000000 – 0x5FFFFFFF</td><td>大小为 512MB，主要用于片上外设。若实现了可选的位带特性，该区域前 1MB 支持位寻址。</td></tr><tr><td>RAM 区</td><td>0x60000000 – 0x9FFFFFFF</td><td>包含两个 512MB 的地址槽位（共 1GB），用于其他 RAM（如片外存储器）；既可用于程序代码，也可用于数据。</td></tr><tr><td>设备区（Devices）</td><td>0xA0000000 – 0xDFFFFFFF</td><td>包含两个 512MB 的地址槽位（共 1GB），用于其他外设（如片外外设）。</td></tr><tr><td>系统区（System）</td><td>0xE0000000 – 0xFFFFFFFF</td><td>系统相关功能的地址空间，包含 PPB、调试与厂商特定区域。</td></tr><tr><td>└─ 内部 PPB</td><td>0xE0040000 – 0xE00FFFFF</td><td>用于访问 NVIC、SysTick、MPU 以及 Cortex-M3/M4 内部调试组件；通常仅特权态代码可访问。</td></tr><tr><td>└─ 外部 PPB</td><td>0xE0040000 – 0xE00FFFFF</td><td>供可选的附加调试组件使用，允许厂商扩展自定义调试或厂商特定组件；仅特权态代码可访问，基地址可能由芯片设计者调整。</td></tr><tr><td>└─ 厂商特定区域</td><td>0xE0100000 – 0xFFFFFFFF</td><td>预留给厂商特定组件，大多数情况下不使用。</td></tr></tbody></table>
<p>下表是系统内建组件</p>
<table><thead><tr><th>组件</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td><strong>NVIC</strong></td><td>Nested Vector Interrupt Controller（嵌套向量中断控制器）</td><td>处理异常（包括中断）的内建中断控制器。</td></tr><tr><td><strong>MPU</strong></td><td>Memory Protection Unit（内存保护单元）</td><td>一种可选的可编程单元，用于配置不同内存区域的访问权限以及访问属性（特性或行为）。部分 Cortex-M3 和 Cortex-M4 微控制器可能不包含 MPU。</td></tr><tr><td><strong>SysTick</strong></td><td>System Tick Timer（系统节拍定时器）</td><td>一个 24 位定时器，主要用于产生周期性的操作系统中断；在不使用操作系统时，也可由应用程序代码使用。</td></tr><tr><td><strong>SCB</strong></td><td>System Control Block（系统控制块）</td><td>一组寄存器，用于控制处理器的行为并提供状态信息。</td></tr><tr><td><strong>FPU</strong></td><td>Floating Point Unit（浮点运算单元）</td><td>该区域放置了一些寄存器，用于控制浮点运算单元的行为并提供状态信息。仅在 Cortex-M4 中可用，且前提是芯片实现了浮点单元。</td></tr><tr><td><strong>FPB</strong></td><td>Flash Patch and Breakpoint Unit（闪存补丁与断点单元）</td><td>用于调试操作。最多包含 8 个比较器，每个都可配置为生成硬件断点事件（例如当执行到某个断点地址的指令时）。它还可以用于替换指令，因此可用于对已固化的程序代码实现补丁机制。</td></tr><tr><td><strong>DWT</strong></td><td>Data Watchpoint and Trace Unit（数据监视点与跟踪单元）</td><td>用于调试和跟踪。最多包含 4 个比较器，每个都可配置为生成数据监视点事件（例如当软件访问某一内存地址范围时）。它还可用于生成数据跟踪包，使调试器能够观察对受监控内存位置的访问。</td></tr><tr><td><strong>ITM</strong></td><td>Instrumentation Trace Macrocell（仪表化跟踪宏单元）</td><td>一种用于调试和跟踪的组件，允许软件生成数据跟踪激励（trace stimulus），并通过跟踪接口捕获；同时还可在跟踪系统中生成时间戳包。</td></tr><tr><td><strong>ETM</strong></td><td>Embedded Trace Macrocell（嵌入式跟踪宏单元）</td><td>用于生成指令级跟踪信息，以支持软件调试。</td></tr><tr><td><strong>TPIU</strong></td><td>Trace Point Interface Unit（跟踪点接口单元）</td><td>用于将来自各个跟踪源的跟踪数据包转换为跟踪接口协议，从而只需最少数量的引脚即可方便地捕获跟踪数据。</td></tr><tr><td><strong>ROM Table</strong></td><td>ROM Table（只读存储器表）</td><td>为调试工具提供的简单查找表，用于指示调试和跟踪组件的地址，使调试工具能够识别系统中可用的调试组件；同时还提供可用于系统识别的 ID 寄存器。</td></tr></tbody></table>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="总线结构">总线结构<a href="#总线结构" class="hash-link" aria-label="Direct link to 总线结构" title="Direct link to 总线结构" translate="no">​</a></h4>
<p>采用 Harvard 总线架构，可以并行访问指令和数据，总线采用 AMBA 标准，包括 AHB （memory bus、system bus）和 APB（peripheral、debug）。在 Cortex-M 处理器中，AHB 是主要的总线接口，APB 用于 PPB（Private Peripheral Bus）主要是调试组件，还可以通过桥接（bus bridge）添加额外的总线（基于 APB 协议）。CODE memory 从 system bus 中分离出来，这样数据访问和取指令可以并行进行。通常来说，MCU 的程序内存（program memory）连接到 I-CODE 和 D-CODE 总线，而 SRAM 和外设（peripheral）连接到系统总线（system bus）。</p>
<p><img decoding="async" loading="lazy" alt="image-20260124100719481" src="/sites/assets/images/image-20260124100719481-e1f55054ae71a1c1a8a6b29f752dd898.png" width="1567" height="1080" class="img_ev3q"></p>
<p>大多数外设都连接到各自分别的外设总线（peripheral bus）上，这种分离的总线结构可以以不同的速率访问外设以优化功耗。外设接口（peripheral interface）通常基于 APB 协议，如果有更高的带宽和操作速度需求也可以使用 AHB Lite，需要注意的是 PPB （Private Peripheral Bus）总线不能用于一般外设。</p>
<p><img decoding="async" loading="lazy" alt="image-20260124103415081" src="/sites/assets/images/image-20260124103415081-c79d62694fadb0f77815700c83a5102f.png" width="1565" height="977" class="img_ev3q"></p>
<p>有两个总线（I-CODE 和 D-CODE）用于访问程序内存（program memory），这两条总线可通过一个总线复用器（bus mutiplexer）合并，MCU vendor 可以利用这个 multiplexier 实现 falsh 的加速访问。</p>
<p><img decoding="async" loading="lazy" alt="image-20260124103803574" src="/sites/assets/images/image-20260124103803574-74f21883dd5af1fe5a6427a5d7194519.png" width="1087" height="489" class="img_ev3q"></p>
<p>MCU 的总线系统（bus system）中通常具有多个主设备（bus master）比如 DMA、Ehternet、USB Controller。文档中通常会提到 bus matrix 和 multi-layer AHB，这个东西指的是总线系统内部包含一个 AHB 的内部连接（interconnect）以允许多个主设备（bus master）可以搬运数据到多个外设（peripheral）或者内存（memory）。下面是一个典型的 bus matrix，每个 bus slave 都连接到这个 bus matrix（interconnect）。带来的好处就是并行访问，比如说，下图中有多个 SRAM，CPU 正在使用其中一个 SRAM 处理数据，同时 DMA controller 正在将外设的数据搬运到另一块 SRAM，此时 USB 也可以使用第三个块 SRAM 。</p>
<p><img decoding="async" loading="lazy" alt="image-20260124104814058" src="/sites/assets/images/image-20260124104814058-dfb8f3e5d9f6ccea971f9517e6cb7684.png" width="1242" height="1654" class="img_ev3q"></p>
<p>下面这个是 STM32 的总线结构</p>
<p><img decoding="async" loading="lazy" alt="image-20260124105543419" src="/sites/assets/images/image-20260124105543419-523a0523aa6b55e450163359fa9782d1.png" width="1189" height="939" class="img_ev3q"></p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="mcu-的内存系统特性memory-system-in-mcu">MCU 的内存系统特性（memory system in MCU）<a href="#mcu-的内存系统特性memory-system-in-mcu" class="hash-link" aria-label="Direct link to MCU 的内存系统特性（memory system in MCU）" title="Direct link to MCU 的内存系统特性（memory system in MCU）" translate="no">​</a></h4>
<p>在很多微控制器中，<strong>除了 CPU 内核本身定义的内存访问方式</strong>，芯片厂商还会在片上加入一些“增强型”的内存系统功能，常见的包括：</p>
<ul>
<li class="">
<p>Boot Loader（引导程序）</p>
</li>
<li class="">
<p>Memory Remapping（内存重映射）</p>
</li>
<li class="">
<p>Memory Alias（内存别名）</p>
</li>
</ul>
<p>这些机制可以实现更灵活的内存映射</p>
<blockquote>
<p>这些功能不是 Cortex-M 处理器内核自带的，而是由芯片厂商自行实现的，不同厂商、不同型号的 MCU 实现方式可能不同。</p>
</blockquote>
<p>除了你自己的代码外，MCU vendor 通常会在一块独立的 ROM （出厂写死，用户无法修改的 Mask ROM、Flash）中，放一段程序用于提供额外功能，这个程序通常就是 Bootloader。</p>
<p>Bootloader 通常具有以下功能</p>
<ul>
<li class="">
<p>程序烧录</p>
<p>通过 UART / USB / CAN 给 Flash 烧录程序，甚至在程序运行时，允许应用自己更新 Flash（IAP）</p>
</li>
<li class="">
<p>提供基础固件或库</p>
<p>比如通信协议栈（USB、CAN、以太网）应用通过 API 调用这些功能</p>
</li>
<li class="">
<p>芯片自检（BIST，Built-In Self Test）</p>
<p>上电后检测 Flash、RAM、外设是否正常</p>
</li>
</ul>
<p>上电或复位后，CPU 会从地址 0 开始取向量表，向量表里包含初始栈指针和Reset_Handler（复位入口），MCU 上电后的第一条指令就来自 Reset_Handler。所以系统启动时，地址 0 必须映射到“当前要运行的程序”。</p>
<p>问题是，第一次上电，需要运行 Boot Loader 以烧录程序，之后再次上电，可能不想再跑 Boot Loader而是直接运行 Flash 里的用户程序。</p>
<p>但问题是：地址 0 只能对应一块存储器，怎么办？这就是 Memory Remap（内存重映射）起作用的地方了。</p>
<p><strong>Memory Remap</strong> 的本质是：通过硬件寄存器，动态改变“地址 0 实际映射到哪块物理存储器”</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0x0000_0000 → Boot Loader ROM // 启动时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x0000_0000 → User Flash	  // 启动后</span><br></span></code></pre></div></div>
<p>为了做到这一点，地址解码器（address decoder）必须是可编程的，这通常是通过一个硬件寄存器（比如位于 system control uint 中的外设寄存器），如下图所示</p>
<p><img decoding="async" loading="lazy" alt="image-20260124155539587" src="/sites/assets/images/image-20260124155539587-7b97fa2b39ee01718a6ef5798e00ba13.png" width="1215" height="1073" class="img_ev3q"></p>
<p>上电启动时，通过地址 0 通过内存别名（memory alias）访问 Bootloader，如下图所示，此时有两个地址可以访问到 Bootloader。Bootloader 中的 reset handler 跳转到 Bootloader 的真实内存中执行，并在后续步骤中关闭内存别名（memory alias），然后 Bootloader 跳转到用户代码执行。</p>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>warning</div><div class="admonitionContent_BuS1"><p>Boot Loader 要修改内存映射，并且还要继续执行代码。这里跳转，是因为你不能在“脚下的内存被切走”的同时还继续执行代码，一旦地址映射发生变化，当前指令地址可能就不再指向原来的代码。所以 Bootloader 在上电时在 alias 地址空间，随后立即跳转到真实地址空间，然后才是关闭 alias，这时地址 0 从原来的指向 Bootloader 的代码变为指向用户程序代码。</p></div></div>
<p><img decoding="async" loading="lazy" alt="image-20260124155618042" src="/sites/assets/images/image-20260124155618042-74db341607c4fc64c02c6bf2c1687179.png" width="1859" height="905" class="img_ev3q"></p>
<p>这只是一种实现方法，具体实现取决于 MCU vendor。实际上也可以完全不使用 Memory Remaping，比如每次启动都执行 Bootloader，然后让 Bootloader 重定位向量表（vetor table），这样也就不存在需要在 0 地址访问不同程序（Bootloader 和 user app）的情况。</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>STM32 的启动模式选择</div><div class="admonitionContent_BuS1"><p>比如说 STM32 就使用硬件的方式，实现内存重映射。通过组合 BOOT0 和 BOOT1，选择从 Flash/System Memory/Embedded SRAM 启动，Flash 中是用户程序，System Memory 中是 Bootloader，可以用于通过 USART 刷写 Flash</p></div></div>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="中断和异常interrupt-and-exception">中断和异常（Interrupt and Exception）<a href="#中断和异常interrupt-and-exception" class="hash-link" aria-label="Direct link to 中断和异常（Interrupt and Exception）" title="Direct link to 中断和异常（Interrupt and Exception）" translate="no">​</a></h3>
<p><img decoding="async" loading="lazy" alt="image-20260124173818241" src="/sites/assets/images/image-20260124173818241-db2dbba674c6f70ad245cf2cb10dc265.png" width="1200" height="713" class="img_ev3q"></p>
<h2 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="stm32-片上外设on-chip-peripheral">STM32 片上外设（on-chip peripheral）<a href="#stm32-片上外设on-chip-peripheral" class="hash-link" aria-label="Direct link to STM32 片上外设（on-chip peripheral）" title="Direct link to STM32 片上外设（on-chip peripheral）" translate="no">​</a></h2>
<p>做嵌入式软件开发有两种手册</p>
<ul>
<li class="">
<p>Reference manual（参考手册）：参考手册主要面向<strong>软件开发者</strong>，是进行底层驱动和寄存器级编程时最核心的文档。</p>
<p>包括各外设的<strong>程序员模型</strong>（寄存器结构、位定义、功能说明）、<strong>内存映射</strong>（Flash、SRAM、外设地址空间等）、外设工作流程、时序、配置方式、中断、DMA、时钟等系统级机制</p>
</li>
<li class="">
<p>Datasheet（数据手册）：数据手册主要面向<strong>硬件设计</strong>，是画原理图、PCB 时的依据。</p>
<p>包括封装类型（LQFP、QFN、BGA 等）、引脚定义与复用功能、工作条件（电压范围、温度范围）、电气特性（输入输出电压、电流、功耗）、时钟、电源、复位等硬件要求</p>
</li>
</ul>
<h2 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="配置开发环境gnu-arm-toolchain--vscode--openocd">配置开发环境（GNU Arm Toolchain + VSCode + OpenOCD）<a href="#配置开发环境gnu-arm-toolchain--vscode--openocd" class="hash-link" aria-label="Direct link to 配置开发环境（GNU Arm Toolchain + VSCode + OpenOCD）" title="Direct link to 配置开发环境（GNU Arm Toolchain + VSCode + OpenOCD）" translate="no">​</a></h2>
<p>先来整体看下嵌入式软件开发流程，从代码编写（coding）和程序编译构建（build）到烧录程序（flash）。</p>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="gnu-arm-toolchain">GNU ARM Toolchain<a href="#gnu-arm-toolchain" class="hash-link" aria-label="Direct link to GNU ARM Toolchain" title="Direct link to GNU ARM Toolchain" translate="no">​</a></h3>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="openocd">OpenOCD<a href="#openocd" class="hash-link" aria-label="Direct link to OpenOCD" title="Direct link to OpenOCD" translate="no">​</a></h3>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="安装和配置开发环境">安装和配置开发环境<a href="#安装和配置开发环境" class="hash-link" aria-label="Direct link to 安装和配置开发环境" title="Direct link to 安装和配置开发环境" translate="no">​</a></h3>
<p>写代码之前当然是配置开发环境，目前有很多种选择包括 Keil、STM32Cube IDE、JetBrains Clion、VSCode。</p>
<p>我选择用 VSCode，准确来说这只是一个代码编辑器，得益于其丰富的插件生态，可以打造为适合任何编程语言的 IDE。</p>
<p>VSCode 有两款主流插件<code>PlatformIO IDE</code> 和 <code>Embedded IDE</code> 可以作为 IDE</p>
<p>但是 <code>PlatformIO IDE</code> 不支持我们要使用的 SPL 库，我们使用 <code>Embedded IDE</code> （EIDE）插件打造开发环境，</p>
<p>这个插件还依赖 .NET 6.0 运行库</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">paru -S dotnet-runtime-6.0-bin</span><br></span></code></pre></div></div>
<p>这个插件（EIDE）只是完整 IDE 一部分，还需要其他插件配合工作，<code>Cortex-Debug</code> 配合 OpenOCD 提供断点调试功能、<code>Serial Monitor</code> 监视串口、<code>C/C++ Extension Pack</code> 添加 C 语言支持、<code>Doxygen Documentation Generator</code> 辅助生成规范的文档化注释。还有很多插件，下面在表格中一一列出，按需安装即可，不必全装</p>
<p><strong>这里是表格</strong></p>
<p>代码编译和项目构建也是借助外部工具的，由 <code>Embedded IDE</code> 调用，安装方法依发行版而异，需要安装这些工具，我这里用的是 Arch Linux</p>
<ul>
<li class=""><a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain" target="_blank" rel="noopener noreferrer" class="">GNU Arm Toolchain</a>：编译器、链接器、二进制工具、调试器、轻量版 C 标准库<!-- -->
<ul>
<li class=""><code>arm-none-eabi-gcc</code></li>
<li class=""><code>arm-none-eabi-binutils</code></li>
<li class=""><code>arm-none-eabi-gdb</code></li>
<li class=""><code>arm-none-eabi-newlib</code></li>
</ul>
</li>
<li class=""><a href="https://openocd.org/" target="_blank" rel="noopener noreferrer" class="">OpenOCD</a>：代码烧录和板上调试工具<!-- -->
<ul>
<li class=""><code>openocd</code></li>
</ul>
</li>
<li class=""><a href="https://cmake.org/" target="_blank" rel="noopener noreferrer" class="">CMake</a>：项目构建系统<!-- -->
<ul>
<li class=""><code>cmake</code></li>
</ul>
</li>
</ul>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ paru -S arm-none-eabi-gcc arm-none-eabi-binutils arm-none-eabi-gdb arm-none-eabi-newlib openocd cmake</span><br></span></code></pre></div></div>
<p>GNU Arm Toolchain</p>
<p><img decoding="async" loading="lazy" alt="The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors 3rd Edition" src="/sites/assets/images/Common-software-compilation-flow-for-GNU-toolchain-5a04768633102c8aa0f6aa0f84c8d190.png" width="1408" height="790" class="img_ev3q"></p>
<p>OpenOCD 调试</p>
<p><img decoding="async" loading="lazy" alt="The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors 3rd Edition" src="/sites/assets/images/Using-a-UART-to-communicate-with-a-PC-via-USB-0fb59cc139df0ab61faab83d4effc655.png" width="1131" height="522" class="img_ev3q"></p>
<h2 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="参考资料">参考资料<a href="#参考资料" class="hash-link" aria-label="Direct link to 参考资料" title="Direct link to 参考资料" translate="no">​</a></h2>
<ul>
<li class="">
<p><a href="https://kleinembedded.com/" target="_blank" rel="noopener noreferrer" class="">Klein Embedded</a>：</p>
<ul>
<li class="">
<p><a href="https://kleinembedded.com/stm32-without-cubeide-part-1-the-bare-necessities/" target="_blank" rel="noopener noreferrer" class="">STM32 without CubeIDE (Part 1): The bare necessities</a></p>
</li>
<li class="">
<p><a href="https://kleinembedded.com/stm32-without-cubeide-part-2-cmsis-make-and-clock-configuration/" target="_blank" rel="noopener noreferrer" class="">STM32 without CubeIDE (Part 2): CMSIS, make and clock configuration</a></p>
</li>
<li class="">
<p><a href="https://kleinembedded.com/stm32-without-cubeide-part-3-the-c-standard-library-and-printf/" target="_blank" rel="noopener noreferrer" class="">STM32 without CubeIDE (Part 3): The C Standard Library and printf()</a></p>
</li>
<li class="">
<p><a href="https://kleinembedded.com/stm32-without-cubeide-part-4-cmake-fpu-and-stm32-libraries/" target="_blank" rel="noopener noreferrer" class="">STM32 without CubeIDE (Part 4): CMake, FPU and STM32 libraries</a></p>
</li>
</ul>
</li>
<li class="">
<p>GitHub@<strong>cpq</strong>：<a href="https://github.com/cpq/bare-metal-programming-guide/blob/main/README_zh-CN.md" target="_blank" rel="noopener noreferrer" class="">裸机编程指南</a></p>
</li>
<li class="">
<p>GitHub@<a href="https://github.com/lowbyteproductions" target="_blank" rel="noopener noreferrer" class="">lowbyteproductions</a></p>
<ul>
<li class=""><a href="https://github.com/lowbyteproductions/bare-metal-series" target="_blank" rel="noopener noreferrer" class="">bare-metal-series</a></li>
<li class="">YouTube@<strong>Low Byte Productions</strong>：<a href="https://www.youtube.com/playlist?list=PLP29wDx6QmW7HaCrRydOnxcy8QmW0SNdQ" target="_blank" rel="noopener noreferrer" class=""><strong>Blinky To Bootloader: Bare Metal Programming Series</strong></a></li>
</ul>
</li>
<li class="">
<p>Interrupt by <a href="https://memfault.com/" target="_blank" rel="noopener noreferrer" class="">Memfault</a></p>
<ul>
<li class=""><a href="https://interrupt.memfault.com/blog/how-to-write-linker-scripts-for-firmware#from-zero-to-main-demystifying-firmware-linker-scripts" target="_blank" rel="noopener noreferrer" class="">From Zero to main(): Demystifying Firmware Linker Scripts</a></li>
<li class=""><a href="https://interrupt.memfault.com/blog/a-modern-c-dev-env" target="_blank" rel="noopener noreferrer" class="">A Modern C Development Environment</a></li>
<li class=""><a href="https://interrupt.memfault.com/blog/get-the-most-out-of-the-linker-map-file" target="_blank" rel="noopener noreferrer" class="">Get the most out of the linker map file</a></li>
</ul>
</li>
<li class="">
<p><code>libopencm3</code></p>
<ul>
<li class=""><a href="https://libopencm3.org/docs/latest/stm32f1/html/modules.html" target="_blank" rel="noopener noreferrer" class="">document</a></li>
<li class=""><a href="https://github.com/libopencm3/libopencm3-examples/tree/master/examples/stm32/f1" target="_blank" rel="noopener noreferrer" class="">example code</a></li>
<li class=""><a href="https://github.com/libopencm3/libopencm3/wiki/Datasheets" target="_blank" rel="noopener noreferrer" class="">Datasheets</a></li>
</ul>
</li>
<li class="">
<p>Make</p>
<ul>
<li class=""><a href="https://makefiletutorial.com/" target="_blank" rel="noopener noreferrer" class="">Learn Makefiles With the tastiest examples</a></li>
</ul>
</li>
<li class="">
<p>CMake</p>
<ul>
<li class="">
<p><a href="https://cliutils.gitlab.io/modern-cmake/README.html" target="_blank" rel="noopener noreferrer" class="">An Introduction to Modern CMake</a></p>
</li>
<li class="">
<p><a href="https://hsf-training.github.io/hsf-training-cmake-webpage/" target="_blank" rel="noopener noreferrer" class="">More Modern CMake</a></p>
</li>
</ul>
</li>
<li class="">
<p><a href="https://github.com/pyocd/pyOCD" target="_blank" rel="noopener noreferrer" class="">pyOCD</a></p>
</li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/WheelsLab/site/tree/master/docs/development/embedded-mcu-dev/stm32-dev-basic/README.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/sites/docs/development/embedded-mcu-dev/bare-metal-programming/bare-metal-programming-without-CubeIDE"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">从 Bare Metal 到 CubeIDE</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/sites/docs/development/embedded-mcu-dev/stm32-dev-basic/GPIO"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">GPIO（通用输出/输出）</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#微控制器mcu-microcontroller概述" class="table-of-contents__link toc-highlight">微控制器（MCU, Microcontroller）概述</a></li><li><a href="#arm-cortex-m" class="table-of-contents__link toc-highlight">ARM Cortex-M</a><ul><li><a href="#内存系统memory-system" class="table-of-contents__link toc-highlight">内存系统（Memory System)</a><ul><li><a href="#内存映射memory-map" class="table-of-contents__link toc-highlight">内存映射（Memory Map）</a></li><li><a href="#总线结构" class="table-of-contents__link toc-highlight">总线结构</a></li><li><a href="#mcu-的内存系统特性memory-system-in-mcu" class="table-of-contents__link toc-highlight">MCU 的内存系统特性（memory system in MCU）</a></li></ul></li><li><a href="#中断和异常interrupt-and-exception" class="table-of-contents__link toc-highlight">中断和异常（Interrupt and Exception）</a></li></ul></li><li><a href="#stm32-片上外设on-chip-peripheral" class="table-of-contents__link toc-highlight">STM32 片上外设（on-chip peripheral）</a></li><li><a href="#配置开发环境gnu-arm-toolchain--vscode--openocd" class="table-of-contents__link toc-highlight">配置开发环境（GNU Arm Toolchain + VSCode + OpenOCD）</a><ul><li><a href="#gnu-arm-toolchain" class="table-of-contents__link toc-highlight">GNU ARM Toolchain</a></li><li><a href="#openocd" class="table-of-contents__link toc-highlight">OpenOCD</a></li><li><a href="#安装和配置开发环境" class="table-of-contents__link toc-highlight">安装和配置开发环境</a></li></ul></li><li><a href="#参考资料" class="table-of-contents__link toc-highlight">参考资料</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/sites/docs/cs-complete">CS 补完计划</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">社交网站</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">其他</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/sites/blog">博客</a></li><li class="footer__item"><a href="https://github.com/WheelsLab" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyleft © 2026 Wheels Lab. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>